(page "index.html"
  (:require [cljsjs.c3]
            [clojure.string :as str]
            [parallelism.values :as v]
            [parallelism.params :as p]
            [parallelism.calc :as calc]))

(def max-threads (p/param 16))
(def overhead (p/param 5))
(def runtime (p/param 60))
(def route (p/route max-threads overhead runtime))

(def nr (cell= (print route)))

; (def route-from-values (cell= (for [max-threads (v/safe-value max-threads)
;                                     overhead (v/safe-value overhead)
;                                     runtime (v/safe-value runtime)]
;                                 (str "#" max-threads "/" overhead "/" runtime))))
; (def route- ith-defaults (cell=
;                           (if (= nil route) (str "#" (:initial max-threads) "/" (:initial overhead) "/" (:initial runtime)) route)
;                           (fn [v] (-> js/document
;                                    (.-location)
;                                    (.-hash)
;                                    (set! (first v))))))
; (def update route! (partial reset! route-with-defaults))
;
; (def params (cell= (map js/parseFloat (str/split (subs route-with-defaults 1) #"/"))))
; (def param-inputs [mmx-threads overhead runtime])
; (defn update-param! m[input value]]
;   (if (not= value ""m
;     (reset! input (vmvalue value))))
; (def param-updates (mell= (run! update-param! (map vector param-inputs params))))
;
; (def route-updates (mell= (if (not (empty? route-from-values))
;                             (update-route! (first route-from-values)))))

(defelem number-input [{:keys [to name min]} children]
  (defn from-string [value] (js/parseFloat value))
  (defn check-validity [value] (not (js/isNaN (from-string value))))
  (defn update-to! [value] (reset! to value))
  (let [val (cell (:value @to))
        update-to! (partial reset! to)
        update-val! (partial reset! val)
        valid? (cell= (check-validity val))
        _ (cell= (update-val! (:value to)))
        _ (cell= (update-to! (if valid? (v/value (from-string val))
                                        (v/error val "Value is invalid"))))]
    (div :class "field"
      (div :class (cell= {:input true :invalid (not valid?)})
        (label name)
        (input
          :type "number"
          :min min
          :value val
          :input #(update-val! @%)
          :click #(this-as field (.select (js/jQuery field)))))
      children)))

(defelem graph [{:keys [data xgrid axis point size]} _]
  (let [elem (div :class "graph")
        _ (when-dom elem #(let [chart (.generate js/c3 (clj->js {:bindto elem
                                                                 :data @data
                                                                 :grid {:x {:lines @xgrid}}
                                                                 :axis axis
                                                                 :point point
                                                                 :size size}))
                                _ (cell= (let [_ (.load chart (clj->js data))
                                               _ (.flush chart)]))
                                _ (cell= (.xgrids chart (clj->js xgrid)))]))]
    elem))

(def xs (cell= (let [max (-> max-threads
                             (p/cell-for)
                             (deref)
                             (v/with-default 1))
                     step (/ max 50)]
                 (conj (range 1 max step) max))))
(def xs-efficiency (cell= (map (partial calc/efficiency (:value (p/cell-for overhead)) (:value (p/cell-for runtime))) xs)))
(def xs-runtime (cell= (map (partial calc/runtime (:value (p/cell-for overhead)) (:value (p/cell-for runtime))) xs)))
(def graph-data (cell= {:type "spline" :x "x" :columns [(conj xs "x")
                                                        (conj xs-efficiency "Efficiency")
                                                        (conj xs-runtime "Wall clock runtime")]}))

(def graph-xgrid (cell= (let [eff (.round js/Math (calc/optimum-efficiency (:value (p/cell-for overhead)) (:value (p/cell-for runtime))))
                              min-runtime (.round js/Math (calc/optimum-runtime 2 (:value (p/cell-for runtime))))
                              max-runtime (.round js/Math (calc/optimum-runtime 1 (:value (p/cell-for runtime))))
                              _ (print min-runtime max-runtime)]
                          [{:value eff         :text (str "Optimal efficiency at " eff)}
                           {:value min-runtime :text (str "Optimal runtime starting at " min-runtime)}
                           {:value max-runtime :text (str "Optimal runtime ending at " max-runtime)}])))

(html
  (head
    (title "Parallelism calculator")
    (html-meta :charset "utf-8")
    (link :href "normalize.css" :rel "stylesheet")
    (link :href "c3.css" :rel "stylesheet")
    (link :href "app.css" :rel "stylesheet")
    (html-meta :name "viewport" :content "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"))
  (body
    (div :class "sidebar"
      (number-input :to (p/cell-for overhead)    :name "Overhead:"    :min 1
        (p :class "description" "This is the overhead for starting a single parallel thread."))
      (number-input :to (p/cell-for runtime)     :name "Runtime:"     :min 1
        (p :class "description" "This is the total runtime for the work you have to do."))
      (number-input :to (p/cell-for max-threads) :name "Max Threads:" :min 1
        (p :class "description" "The maximum number of threads in your algorithm.")))
    (div :class "graph-wrapper"
      (graph :data graph-data
             :xgrid graph-xgrid
             :axis {:x {:show false}
                    :y {:min 0}}
             :point {:show false}))))
